<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>優化版動態愛心</title>
    <style>
        body { margin: 0; background-color: black; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { display: block; }
    </style>
</head>
<body>

<canvas id="heartCanvas"></canvas>

<script>
    const canvas = document.getElementById('heartCanvas');
    const ctx = canvas.getContext('2d');

    const CANVAS_WIDTH = 640, CANVAS_HEIGHT = 480;
    const HEART_COLOR = "#ff2121", IMAGE_ENLARGE = 11;
    canvas.width = CANVAS_WIDTH; canvas.height = CANVAS_HEIGHT;

    const CENTER_X = CANVAS_WIDTH / 2, CENTER_Y = CANVAS_HEIGHT / 2;

    function heartFunction(t, shrinkRatio = IMAGE_ENLARGE) {
        let x = 16 * Math.pow(Math.sin(t), 3);
        let y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
        return { x: x * shrinkRatio + CENTER_X, y: y * shrinkRatio + CENTER_Y };
    }

    // 優化過的擴散函數：減少向中心直線塌陷的機率
    function scatterInside(x, y, beta = 0.15) {
        let ratioX = -beta * Math.log(Math.random());
        let ratioY = -beta * Math.log(Math.random());

        // 加入少許切向偏移，避免點全部往正中心縮
        let dx = ratioX * (x - CENTER_X) + (Math.random() - 0.5) * 5;
        let dy = ratioY * (y - CENTER_Y) + (Math.random() - 0.5) * 5;

        return { x: x - dx, y: y - dy };
    }

    function calcPosition(x, y, ratio) {
        let distSq = Math.pow(x - CENTER_X, 2) + Math.pow(y - CENTER_Y, 2);
        let force = 1 / Math.pow(distSq, 0.52);
        
        return { 
            x: x - (ratio * force * (x - CENTER_X) + (Math.random() * 1.5 - 0.75)), 
            y: y - (ratio * force * (y - CENTER_Y) + (Math.random() * 1.5 - 0.75)) 
        };
    }

    function curve(p) {
        return 2 * (Math.sin(4 * p)) / Math.PI;
    }

    class Heart {
        constructor() {
            this.points = []; this.edgePoints = []; this.centerPoints = [];
            
            // 1. 構建輪廓
            for (let i = 0; i < 1800; i++) {
                this.points.push(heartFunction(Math.random() * 2 * Math.PI));
            }

            // 2. 構建邊緣擴散
            this.points.forEach(p => {
                for (let i = 0; i < 2; i++) { // 減少重複點，避免過厚
                    this.edgePoints.push(scatterInside(p.x, p.y, 0.05));
                }
            });

            // 3. 構建內部點（降低數量，避免中心連成一線）
            for (let i = 0; i < 2500; i++) { 
                let p = this.points[Math.floor(Math.random() * this.points.length)];
                // 增加隨機性，打破直線感
                this.centerPoints.push(scatterInside(p.x, p.y, 0.18));
            }
        }

        draw(frame) {
            let ratio = 8 * curve(frame / 45 * Math.PI); // 減小跳動幅度
            ctx.fillStyle = HEART_COLOR;

            [this.points, this.edgePoints, this.centerPoints].forEach(set => {
                set.forEach(p => {
                    let pos = calcPosition(p.x, p.y, ratio);
                    ctx.fillRect(pos.x, pos.y, 1.2, 1.2); // 稍微放大點的大小，增加霧感
                });
            });
            
            // 繪製微弱的光暈
            for (let i = 0; i < 800; i++) {
                let t = Math.random() * 2 * Math.PI;
                let pos = heartFunction(t, IMAGE_ENLARGE + 6);
                let finalPos = scatterInside(pos.x, pos.y, 0.1);
                ctx.fillRect(finalPos.x, finalPos.y, 1, 1);
            }
        }
    }

    const heart = new Heart();
    let frame = 0;
    let lastTime = 0;
    const fps = 24; 

    function render(timestamp) {
        if (timestamp - lastTime > 1000 / fps) {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            heart.draw(frame);
            frame = (frame + 1) % 180; 
            lastTime = timestamp;
        }
        requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
</script>
</body>
</html>